"""Utilities to audit call graph artefacts before feeding them to the UI."""

from __future__ import annotations

from dataclasses import dataclass
import json
from pathlib import Path
from typing import Iterable, List, Sequence


@dataclass(slots=True)
class GraphSummary:
    """Lightweight metadata describing a call graph JSON file."""

    path: Path
    relative_path: str
    program: str | None
    node_count: int
    edge_count: int
    status: str
    reason: str | None = None

    def to_dict(self) -> dict[str, object]:
        return {
            "path": str(self.path),
            "relative_path": self.relative_path,
            "program": self.program,
            "node_count": self.node_count,
            "edge_count": self.edge_count,
            "status": self.status,
            "reason": self.reason,
        }


def _count_nodes(payload: dict[str, object]) -> int:
    if "functions" in payload and isinstance(payload["functions"], list):
        return len(payload["functions"])
    if "nodes" in payload and isinstance(payload["nodes"], list):
        return len(payload["nodes"])
    return int(payload.get("node_count") or 0)


def _count_edges(payload: dict[str, object]) -> int:
    if "edges" in payload and isinstance(payload["edges"], list):
        return len(payload["edges"])
    return int(payload.get("edge_count") or 0)


def scan_call_graphs(
    base_dir: Path,
    pattern: str = "*.callgraph.json",
) -> list[GraphSummary]:
    """
    Enumerate call graph artefacts and flag empty or malformed files.

    Returns summaries for every graph discovered under ``base_dir``.
    """

    base_dir = base_dir.expanduser().resolve()
    summaries: list[GraphSummary] = []

    for path in sorted(base_dir.rglob(pattern)):
        if not path.is_file():
            continue
        relative_path = str(path.resolve().relative_to(base_dir))
        try:
            payload = json.loads(path.read_text(encoding="utf-8"))
        except Exception as exc:  # pragma: no cover - file system dependent
            summaries.append(
                GraphSummary(
                    path=path.resolve(),
                    relative_path=relative_path,
                    program=None,
                    node_count=0,
                    edge_count=0,
                    status="error",
                    reason=str(exc),
                )
            )
            continue

        program = None
        graph_meta = payload.get("graph")
        if isinstance(graph_meta, dict):
            program = graph_meta.get("program") or graph_meta.get("programs")
            if isinstance(program, (list, tuple)):
                program = ", ".join(str(item) for item in program)
            elif program is not None:
                program = str(program)
        program = program or str(payload.get("program") or "")
        if not program:
            program = None

        node_count = _count_nodes(payload)
        edge_count = _count_edges(payload)

        if node_count == 0 or edge_count == 0:
            status = "empty"
            reason = "no nodes" if node_count == 0 else "no edges"
        else:
            status = "ok"
            reason = None

        summaries.append(
            GraphSummary(
                path=path.resolve(),
                relative_path=relative_path,
                program=program,
                node_count=node_count,
                edge_count=edge_count,
                status=status,
                reason=reason,
            )
        )

    return summaries


def write_summary_report(
    summaries: Sequence[GraphSummary],
    output: Path,
    *,
    format: str = "json",
) -> None:
    """
    Persist the provided summaries to ``output`` in JSON or Markdown.
    """

    output = output.expanduser().resolve()
    output.parent.mkdir(parents=True, exist_ok=True)
    fmt = format.lower()

    if fmt == "json":
        payload = [summary.to_dict() for summary in summaries]
        output.write_text(json.dumps(payload, indent=2), encoding="utf-8")
        return

    if fmt in {"md", "markdown"}:
        lines = [
            "| Relative Path | Program | Nodes | Edges | Status | Reason |",
            "| --- | --- | ---:| ---:| --- | --- |",
        ]
        for summary in summaries:
            lines.append(
                f"| {summary.relative_path} | {summary.program or ''} | "
                f"{summary.node_count} | {summary.edge_count} | {summary.status} | {summary.reason or ''} |"
            )
        output.write_text("\n".join(lines) + "\n", encoding="utf-8")
        return

    raise ValueError(f"Unsupported report format: {format}")


def load_excluded_paths(report_path: Path, data_dir: Path) -> set[Path]:
    """
    Load a JSON report generated by ``write_summary_report`` and return the paths to skip.
    """

    report_path = report_path.expanduser().resolve()
    data_dir = data_dir.expanduser().resolve()
    if not report_path.exists():
        raise FileNotFoundError(f"Exclusion report not found: {report_path}")

    payload = json.loads(report_path.read_text(encoding="utf-8"))
    if not isinstance(payload, list):
        raise ValueError("Exclusion report must be a JSON array.")

    excluded: set[Path] = set()
    for entry in payload:
        if not isinstance(entry, dict):
            continue
        rel = entry.get("relative_path")
        absolute = entry.get("path")
        candidate: Path | None = None
        if isinstance(rel, str) and rel:
            candidate = (data_dir / rel).resolve()
        elif isinstance(absolute, str) and absolute:
            candidate = Path(absolute).expanduser().resolve()
        if candidate is not None:
            excluded.add(candidate)

    return excluded


__all__ = [
    "GraphSummary",
    "load_excluded_paths",
    "scan_call_graphs",
    "write_summary_report",
]

Metadata-Version: 2.4
Name: call-graph-win11
Version: 0.1.0
Summary: Tooling to reconstruct call graphs for Windows system libraries and analyse syscall coverage.
Author: Semester Project Team
Requires-Python: >=3.12
Description-Content-Type: text/markdown
Requires-Dist: click>=8.1
Requires-Dist: igraph>=0.11
Requires-Dist: networkx>=3.2
Requires-Dist: pydantic>=2.7
Requires-Dist: pyyaml>=6.0
Requires-Dist: rich>=13.7
Requires-Dist: typer>=0.12
Requires-Dist: pefile>=2024.8
Requires-Dist: requests>=2.32
Requires-Dist: matplotlib>=3.9
Requires-Dist: dash>=2.16
Requires-Dist: dash-cytoscape>=0.3
Provides-Extra: dev
Requires-Dist: black>=24.8; extra == "dev"
Requires-Dist: mypy>=1.11; extra == "dev"
Requires-Dist: pytest>=8.3; extra == "dev"
Requires-Dist: pytest-cov>=5.0; extra == "dev"
Requires-Dist: ruff>=0.6; extra == "dev"
Requires-Dist: types-PyYAML>=6.0.12; extra == "dev"

# Call Graph Reconstruction for Windows System Libraries

This repository contains the scaffolding for the Spring 2025 semester project
guided by Prof. Davide Balzarotti and Andrea Oliveri. The goal is to reconstruct
and analyse the call graph that links Windows system library functions to the
NTDLL syscalls they eventually trigger. A clear project overview is available in
`balzarotti_fall25_proj3.pdf`; the extracted plaintext reference lives in
`project_description.txt`.

## Windows Library Call Stack

Windows splits user-mode services across multiple layers.  High-level DLLs in
`System32` (e.g., `kernel32`, `advapi32`, `user32`) present ergonomic APIs to
applications, but most of those functions are thin wrappers or state machines
that ultimately delegate to \texttt{ntdll.dll}.  The latter contains the
syscall stubs that transition into kernel mode.  Hooking only the syscalls
produces too much noise (every process shares the same syscall surface), while
hooking an entire user-mode DLL is prohibitively expensive.

Building a graph that connects each exported API down to the syscall(s) it
triggers gives analysts two advantages:

- **Precision** – we can focus on the handful of APIs that actually reach the
  syscalls needed to monitor a behaviour of interest, instead of instrumenting
  hundreds of unrelated exports.
- **Coverage reasoning** – reachability analysis shows which syscalls remain
  uncovered, guiding additional reverse engineering or dynamic tracing.

The tooling in this repository automates that mapping so the minimal,
high-signal hook set can be derived programmatically, with the Dash explorer
backed by `igraph` for high-performance traversals and layout generation.

## Getting Started

```powershell
# 1. Create and activate a virtual environment
python -m venv .venv
.venv\Scripts\Activate

# 2. Upgrade pip and install dependencies
python -m pip install --upgrade pip
pip install -e .[dev]

# 3. Run the default checks
pytest
```

## CLI Usage

The project exposes its tooling through a Typer-based CLI. If you installed the
package with `pip install -e .`, the `call-graph` entrypoint is available on
your PATH; otherwise invoke the module directly with `python -m
call_graph_win11.cli`. Use `--help` on any command to inspect its options.

```powershell
call-graph --help
call-graph inventory --help
```

### Typical workflow

1. **Inventory the Windows installation**

   ```powershell
   call-graph inventory `
       --root C:\Windows `
       --output data/raw/windows_inventory `
       --limit 250             # optional: restrict for dry runs
   ```

2. **Fetch matching PDBs for the collected RSDS signatures**

   ```powershell
   call-graph fetch-pdbs `
       --metadata-root data/raw/windows_inventory `
       --output-root data/external/pdbs `
       --cache-root D:\symbol-cache   # optional shared cache
   ```

3. **Export call graphs with Ghidra (single run)**

   ```powershell
   call-graph ghidra-callgraph `
       --binary C:\Windows\System32\kernel32.dll `
       --binary C:\Windows\System32\advapi32.dll `
       --project-root ghidra-projects `
       --metadata-root data/raw/windows_inventory `
       --pdb-root data/external/pdbs `
       --output-dir data/interim/call_graphs `
       --overwrite
   ```

   To sweep whole directories, switch to the batch command:

   ```powershell
   call-graph callgraph-batch `
       --include System32 --include SysWOW64 `
       --metadata-root data/raw/windows_inventory `
       --windows-root C:\Windows `
       --output-dir data/interim/call_graphs `
       --pdb-root data/external/pdbs
   ```

4. **Generate analytics and reports**

   ```powershell
   call-graph callgraph-syscall-report `
       --input data/interim/call_graphs/System32/kernel32.dll.callgraph.json `
       --top 20

   call-graph callgraph-hook-plan `
       --input data/interim/call_graphs/System32/kernel32.dll.callgraph.json `
       --program kernel32.dll `
       --max-uncovered 25
   ```

5. **Visualise or aggregate**

   ```powershell
   call-graph callgraph-aggregate `
       --input data/interim/call_graphs/System32/*.callgraph.json `
       --output docs/analytics/kernel32_kernelbase.json `
       --visualize docs/analytics/kernel32_kernelbase.png

   call-graph callgraph-visualize `
       --input data/interim/call_graphs/System32/kernel32.dll.callgraph.json `
       --show-labels
   ```

6. **Launch the Dash explorer**

   ```powershell
   call-graph callgraph-ui --data-dir data/interim/call_graphs --port 8051
   ```

All of these steps are orchestrated end-to-end by
`scripts/run_full_pipeline.ps1`, which chains inventory, PDB mirroring, batch
exports, CSV generation, and analytics reports for reproducible runs.

### Tooling Requirements

- Python 3.12+
- One or more reverse engineering frameworks (Ghidra, IDA Pro)
- Access to a reference Windows 11 installation (x64) whose system libraries can
  be inspected
- Optional: Graph tooling (Graphviz) for visualisation

## Repository Layout

```
.
├── balzarotti_fall25_proj3.pdf      # Official project description
├── configs/                         # YAML/JSON config files for runs
├── data/
│   ├── external/                    # Vendor-supplied datasets (e.g., MSDN exports)
│   ├── interim/                     # Intermediate processing artefacts
│   ├── processed/                   # Final graphs and analytics
│   └── raw/                         # Direct dumps from reverse engineering tools
├── docs/
│   ├── meeting-notes/               # Templates & dated discussion notes
│   ├── references/                  # Curated reading material and links
│   └── research/                    # Experiments, methodologies, design drafts
├── notebooks/                       # Jupyter notebooks for exploratory analysis
├── scripts/                         # CLI scripts and automation helpers
├── src/call_graph_win11/            # Python package with project code
│   ├── analysis/                    # Graph queries and metrics
│   ├── data/                        # Parsers and collectors
│   ├── io/                          # Input/output integration (Ghidra, IDA, exports)
│   └── pipelines/                   # Orchestrated workflows for building graphs
└── tests/                           # Pytest-based regression and unit tests
```

## Roadmap

1. **Inventory Windows libraries**: catalogue DLLs from the target system and
   capture metadata (exported symbols, PE headers, signatures).
2. **Automate call graph extraction**: develop repeatable scripts for your
   chosen tooling (Ghidra/IDA) to dump per-library call graphs.
3. **Unify graphs**: normalise, merge, and deduplicate the per-library data into
   a global graph compatible with the `igraph` and `networkx` APIs provided in
   `src/call_graph_win11/analysis`.
4. **Analysis layer**: implement the queries outlined in the project brief to
   surface interesting syscall paths and minimal hooking sets.
5. **Reporting**: document findings in `docs/research/` and track open decisions
   via `docs/meeting-notes/`.

## Discovery Scripts

Run the Windows library inventory pass (writes per-file JSON metadata under
`data/raw/windows_inventory`), pull matching PDBs, and keep data scoped with
`--limit` while iterating:

```powershell
python -m call_graph_win11.cli inventory
python -m call_graph_win11.cli fetch-pdbs --pdb-name ntdll.pdb --pdb-name kernel32.pdb --pdb-name user32.pdb --limit 3
```

Use `--limit <n>` for a quick dry run and `--output <path>` to redirect the
inventory elsewhere. Sample validation for `ntdll.dll`, `kernel32.dll`, and
`user32.dll` is performed automatically. Symbol downloads are stored under
`data/external/pdbs/` using the standard symbol-server directory layout. Add
`--cache-root <path>` to point at a larger, shared symbol cache; downloads are
stored once under that root and hard-linked/copied into the requested `--output`
location so repeated runs avoid re-fetching identical GUIDs.

- Consolidate the collected metadata into a single CSV overview:
  ```powershell
  python -m call_graph_win11.cli inventory-csv `
      --metadata-root data/raw/windows_inventory `
      --output-csv docs/windows_inventory_summary.csv `
      --relative-to C:\Windows
```
The CSV captures core PE attributes (machine, subsystem, entry point, section
count), export/import counts, and the primary RSDS/PDB linkage when present.

### Automated Pipeline

Run the full acquisition and analysis loop with a single command:

```powershell
.\scripts\run_full_pipeline.ps1 `
    -WindowsRoot C:\Windows `
    -MetadataDir data/raw/windows_inventory `
    -PdbDir data/external/pdbs `
    -CallGraphDir data/interim/call_graphs `
    -CsvOutput docs/windows_inventory_summary.csv `
    -ReportsDir docs/analytics `
    -Limit 50
```

The script orchestrates `inventory → fetch-pdbs → callgraph-batch → inventory-csv`
and drops the latest CLI reports under `docs/analytics/` (syscall reachability,
greedy hook plan, and any notebook-exported CSVs).

## Ghidra Call Graph Export

Once the metadata and PDBs are in place, you can exercise the headless Ghidra
workflow (requires a local Ghidra installation):

```powershell
python -m call_graph_win11.cli ghidra-callgraph `
    --binary C:\Windows\System32\ntdll.dll `
    --binary C:\Windows\System32\kernel32.dll `
    --binary C:\Windows\System32\user32.dll `
    --project-root ghidra-projects `
    --project-name call_graph_samples
```

The command invokes `scripts/ghidra/export_call_graph.py`, which writes graph
JSON to `data/interim/call_graphs/<binary>.callgraph.json`. Pass `--overwrite`
to regenerate existing outputs or `--script-path` to point at custom exporters.
When PDBs are available in `data/external/pdbs/`, the CLI wires them into
Ghidra via a pre-script before exporting the call graph, so recovered symbol
names are preserved in the JSON output.

## Graph Exploration

- Visualise an individual call graph (PNG output in `data/interim/figures/`):
  ```powershell
  python -m call_graph_win11.cli callgraph-visualize `
      --input data/interim/call_graphs/ntdll.dll.callgraph.json `
      --max-nodes 250
  ```

- Merge multiple call graphs, emit a combined artefact (JSON/GraphML), and render a summary view:
  ```powershell
  python -m call_graph_win11.cli callgraph-aggregate `
      --input data/interim/call_graphs/ntdll.dll.callgraph.json `
      --input data/interim/call_graphs/kernel32.dll.callgraph.json `
      --input data/interim/call_graphs/user32.dll.callgraph.json `
      --output data/interim/call_graphs/samples_combined.json `
      --format graphml `
      --visualize data/interim/figures/samples_combined.png `
      --max-nodes 300
  ```

- Inspect igraph centrality metrics (degree, betweenness, PageRank) from the command line:
  ```powershell
  python -m call_graph_win11.cli callgraph-igraph-summary `
      --input data/interim/call_graphs/ntdll.dll.callgraph.json `
      --input data/interim/call_graphs/kernel32.dll.callgraph.json `
      --input data/interim/call_graphs/user32.dll.callgraph.json `
      --metric betweenness `
      --top 15
  ```

  The aggregated GraphML output opens smoothly in GUI tools such as Gephi, Cytoscape, or yEd for deeper interactive exploration.

- Audit syscall reachability or derive greedy hook recommendations:
  ```powershell
  python -m call_graph_win11.cli callgraph-syscall-report `
      --input data/interim/call_graphs/System32/ntdll.dll.callgraph.json `
      --top 10

  python -m call_graph_win11.cli callgraph-hook-plan `
      --input data/interim/call_graphs/System32/advapi32.dll.callgraph.json `
      --input data/interim/call_graphs/System32/ntdll.dll.callgraph.json `
      --program advapi32.dll
  ```
  The first command lists orphaned syscalls and APIs that never reach them, while the second approximates a minimal set of API hooks that covers the reachable syscalls.

- Launch the interactive Dash UI to browse binaries and inspect subgraphs:
  ```powershell
  python -m call_graph_win11.cli callgraph-ui `
      --data-dir data/interim/call_graphs `
      --host 127.0.0.1 `
      --port 8050
  ```
  Use the dropdown to pick a library, adjust the node limit slider to focus on the busiest region, and hover nodes for attributes. Key UI controls:
  - `Highlight`: free-text search that soft-highlights matching nodes and their incident edges.
  - `Filters`: quickly scope the graph to syscalls (`Nt*/Zw*`) or exported APIs only.
  - `Preset highlight`: choose between hook candidates, syscall-free APIs, or the greedy hook set computed for the current library.
  - `Graph layout`: toggle between force-directed, concentric, and breadth-first layouts (powered by igraph) to inspect structure from different viewpoints.
  - `Node size`: switch between fixed nodes or degree-scaled sizing to surface potential hubs instantly.
  - `Inbound depth`: choose how many hops of inbound callers to include when focusing on a target function.
  - `Path inspector`: select a `Start` and `Focus` function to render the shortest path preview and a compact Cytoscape subgraph with start/end colour accents.
  - Sidebar panels (`Stats`, `Program Legend`, `Top degree functions`, `Syscall coverage`) summarise graph composition, colour assignments, and hook recommendations. Coverage badges call out “Top 5%” and “Bottom 10%” candidates, while zero-coverage APIs receive a neutral chip so analysts can triage at a glance.

## Batch Extraction (System32 & SysWOW64)

Automate call-graph generation for the core Windows directories. The command below walks the inventory, filters binaries that live under `C:\Windows\System32` or `C:\Windows\SysWOW64`, fetches the required PDBs, and writes the results to `data/interim/call_graphs/<relative_path>.callgraph.json`.

```powershell
python -m call_graph_win11.cli callgraph-batch `
    --ghidra-headless "C:\Users\Baha\Tools\ghidra\ghidra_11.4.2_PUBLIC\support\analyzeHeadless.bat" `
    --project-root ghidra-projects `
    --project-name win_batch `
    --overwrite
```

Useful flags:

- `--include` to add more subdirectories (defaults to `System32` and `SysWOW64`).
- `--limit` for dry-run testing.
- `--symbol-path` to supply an explicit PDB search path (otherwise the pipeline falls back to `data/external/pdbs`).

The notebooks `notebooks/sample_call_graph_analysis.ipynb` and `notebooks/call_graph_analysis_demo.ipynb` demonstrate how to load and analyse these artefacts interactively (degree statistics, syscall coverage, inspection of top callers, etc.). Executing them now normalises cell IDs, captures outputs, and writes summary CSVs in `docs/analytics/`. The corresponding Ghidra scripts are mirrored under `docs/ghidra-scripts/` for inspection or manual use.

## Contributing

1. Create a feature branch.
2. Ensure linting and tests pass: `pytest`.
3. Submit your changes for review or merge when ready.

> Tip: use `scripts/bootstrap_env.ps1` to recreate the local environment quickly.

Happy reversing!


